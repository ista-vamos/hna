#ifndef HNA_MONITOR_H_
#define HNA_MONITOR_H_

#include <list>
#include <memory>
#include <vector>
#include <mutex>

#include "monitor.h"
#include "monitor-with-traces.h"
#include "trace.h"
#include "traceset.h"
#include "verdict.h"
#include "slice-tree-node.h"

// generated
#include "events.h"
#include "slice-tree.h"


class HNAMonitor : public Monitor {
  SlicesTree _slices_tree;
  // Mapping of traces (their IDs) to slices they are currently in
  std::map<unsigned, SliceTreeNode *> _trace_to_slice;

  SliceTreeNode *getSlice(unsigned trace_id);
  SliceTreeNode *getOrCreateSlice(SliceTreeNode *current_node,
                                  unsigned trace_id, const ActionEvent &e);

  bool _traces_finished{false};
  // updating traces can yield a verdict (e.g., if there is no
  // matching action in the HNA). If that happens, it is stored here
  // and returned on the next call of `step`.
  Verdict _result{Verdict::UNKNOWN};

public:
  /*
   AtomMonitor *createAtomMonitor(Action monitor_type, HNLInstance&);
   void removeInstance(HNLInstance *instance);
   */

  // adding and extending traces
  void newTrace(unsigned id);
  void extendTrace(unsigned trace_id, const ActionEvent &e);
  void traceFinished(unsigned trace_id);
  void noFutureUpdates();

  Verdict step();

  // statistics
  struct {
    // number of HNL monitors
    size_t num_hnl_monitors{1};

    // CPU time taken by running the HNL monitor
    #ifdef MEASURE_CPUTIME
    struct timespec cputime{0, 0};
    #endif
  } stats;
};

#endif
