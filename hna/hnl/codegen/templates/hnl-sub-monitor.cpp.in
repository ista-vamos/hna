// template: hnl-sub-monitor.cpp.in

#include <cassert>

#include "hnl-monitor.h"

@namespace_start@

/* GENERATED */
#include "functions.h"
#include "hnl-monitor-ctors-dtors.h"

void HNLMonitor::addNewTraces() {
  /* GENERATED */
  #include "create-instances.h"
}

static inline Verdict negate_verdict(Verdict v) {
    assert(v != Verdict::UNKNOWN);
    return v == Verdict::FALSE ? Verdict::TRUE : Verdict::FALSE;
}

Verdict HNLMonitor::step() {
  Verdict verdict;

  unsigned empty_slots{0};
  const auto n_monitors = _instances.size();

  for (unsigned n = 0; n < n_monitors; ++n) {
      auto &instance = _instances[n];
      if (!instance) {
          ++empty_slots;
          continue;
      }
      if ((verdict = instance->monitor->step()) != Verdict::UNKNOWN) {
          // this monitor is done
          _instances[n].reset();
          ++empty_slots;

          @process_submonitor_verdict@
      }
  }

  if (static_cast<float>(empty_slots) / n_monitors > 0.3) {
      condenseWbg();
  }

  addNewTraces();
  bool finished = inputs_finished() && _instances.empty();

  if (finished) {
      return Verdict::TRUE;
  }

  return Verdict::UNKNOWN;
}

bool HNLMonitor::inputs_finished() {
    if (_inputs_finished)
        return true;

    @inputs_finished@

    _inputs_finished = true;
    return true;
}


void HNLMonitor::condenseWbg() {
    if (_instances.empty())
        return;

    // FIXME: do it in place without creating a new vector
    decltype(_instances) tmp;
    tmp.reserve(_instances.size());

    for (auto &ptr : _instances) {
        if (ptr) {
            tmp.push_back(std::move(ptr));
        }
    }
    _instances.swap(tmp);
}

@namespace_end@
