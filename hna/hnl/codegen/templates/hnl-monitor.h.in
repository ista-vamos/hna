// template: hnl-monitor.h.in

#ifndef HNLMONITOR_H_
#define HNLMONITOR_H_

#include <memory>

#include "monitor.h"
#include "traceset.h"
#include "function.h"
#include "cmd.h"
#include "submonitor/hnl-monitor.h"

#include "functions.h"
#include "alltracesets.h"

@namespace_start@

///
// The top-level class for HNL monitor for an arbitrary HNL formula
class HNLMonitor : public ::Monitor {
  // All traces for this monitor (and submonitors).
  // The submonitors will have only a view of this container
  TraceSet _traces;
  CmdArgs *_cmd;

  @functions@

  // An object containing a reference to _traces and all functions.
  // We use it to pass these references around to monitors.
  const AllTraceSets allTraceSets;

  // This class is a wrapper and a container for traces (including function traces).
  // The actual monitoring happens in this submonitor.
  sub::HNLMonitor _monitor;

public:
  HNLMonitor(CmdArgs *cmd = nullptr)
    : _cmd(cmd)
      @functions_init@,
      allTraceSets(@alltracesets_init@),
      _monitor(allTraceSets) {}

  //virtual ~HNLMonitor() {}

  // adding and extending traces
  void newTrace(unsigned trace_id);
  void extendTrace(unsigned trace_id, const Event &e);
  void traceFinished(unsigned trace_id);
  void noFutureUpdates();
  bool allTracesFinished();
  bool hasTrace(unsigned trace_id);

  /// This method calls `step` for the function traces generators
  //  and then calls `step` of `_monitor`.
  // Note that there is no need to do anything about `_traces` as that
  // container is being filled asynchronously by the input thread
  Verdict step();

  // statistics
  struct {
    // number of HNL configurations
    size_t num_instances{0};

    // CPU time taken by running the HNL monitor
    #ifdef MEASURE_CPUTIME
    struct timespec cputime{0, 0};
    #endif
  } stats;
};

@namespace_end@

#endif // HNLMONITOR_H_
