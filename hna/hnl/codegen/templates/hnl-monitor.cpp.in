#ifdef MEASURE_CPUTIME
#include <ctime>
#endif // !MEASURE_CPUTIME

#include <cassert>

#include "hnl-monitor.h"

/* generated part START */
#include "hnl-state.h"
/* generated part END */

@namespace_start@

static inline Verdict do_step(AtomMonitor *M) {
  #include "do_step.h"
}

bool HNLMonitor::addNewTraces() {
  if (auto *t1 = _traces.getNewTrace()) {
      /* GENERATED */
      #include "create-instances.h"
  }

  return _traces.finished();
}

Verdict HNLMonitor::updateInstance(HNLInstance *instance, Verdict verdict) {
    removeInstance(instance);

    if (verdict == Verdict::FALSE) {
        return Verdict::TRUE;
    }

    if (verdict == Verdict::TRUE) {
        return Verdict::FALSE;
    }

    assert(false && "Unreachable");
    abort();
    return Verdict::UNKNOWN;
}

Verdict HNLMonitor::step() {
#ifdef MEASURE_CPUTIME
    struct timespec start, end;
    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &start);
#endif // !MEASURE_CPUTIME

  Verdict verdict;

  unsigned empty_slots{0};
  const auto n_monitors = _monitors_wbg.size();
  for (unsigned n = 0; n < n_monitors; ++n) {
      auto *monitor = _monitors_wbg[n];
      if (!monitor) {
          ++empty_slots;
          continue;
      }
      if ((verdict = do_step(monitor)) != Verdict::UNKNOWN) {

          for (auto it = monitor->used_by_begin(),
                    et = monitor->used_by_end(); it != et; ++it) {
              if (updateInstance(*it, verdict) == Verdict::FALSE) {
                  return Verdict::FALSE;
              }
          }

          // this monitor is done
          _monitors_wbg[n] = nullptr;
          ++empty_slots;
      }
  }

  if (static_cast<float>(empty_slots) / n_monitors > 0.3) {
      condenseWbg();
  }

/*
#ifdef MEASURE_CPUTIME
  clock_gettime(CLOCK_THREAD_CPUTIME_ID, &end);
  stats.cputime.tv_sec += (end.tv_sec - start.tv_sec);
  stats.cputime.tv_nsec += (end.tv_nsec - start.tv_nsec);
#endif // !MEASURE_CPUTIME

#ifdef MEASURE_CPUTIME
  clock_gettime(CLOCK_THREAD_CPUTIME_ID, &start);
#endif // !MEASURE_CPUTIME

  bool traces_finished = addNewTraces();

#ifdef MEASURE_CPUTIME
  clock_gettime(CLOCK_THREAD_CPUTIME_ID, &end);
  stats.cputime.tv_sec += (end.tv_sec - start.tv_sec);
  stats.cputime.tv_nsec += (end.tv_nsec - start.tv_nsec);
  stats.cputime_adding_instances.tv_sec += (end.tv_sec - start.tv_sec);
  stats.cputime_adding_instances.tv_nsec += (end.tv_nsec - start.tv_nsec);
#endif // !MEASURE_CPUTIME
*/
  bool finished = traces_finished && _monitors_wbg.empty();//_instances.empty();

  /* GENERATED */
  /* It can modify the `finished` variable */
  #include "gen-function-traces.h"

  if (finished) {
      assert(_monitors_wbg.empty());
      return Verdict::TRUE;
  }

  return Verdict::UNKNOWN;
}

HNLSubMonitorBase *HNLMonitor::createMonitor(HNLEvaluationState monitor_type, HNLInstance& instance) {
    assert(monitor_type > 0 && "Invalid monitor type");

    AtomMonitor *monitor{nullptr};

    /* GENERATED */
    #include "create-atom-monitor.h"

    assert(monitor && "Monitor not found/created");
    //_atom_monitors.emplace_back(monitor);
    _monitors_wbg.push_back(monitor);
    ++stats.num_atoms;

    assert(monitor && "Monitor not found/created");
    monitor->setUsedBy(instance);

    return monitor;
}

void HNLMonitor::removeInstance(HNLInstance *instance) {
    delete instance;
}


/*
void HNLMonitor::deleteAtomMonitor(AtomMonitor *m) {
    delete m;
}
*/

void HNLMonitor::condenseWbg() {
    if (_monitors_wbg.empty())
        return;

    // FIXME: do it in place without creating a new vector
    decltype(_monitors_wbg) tmp;
    tmp.reserve(_monitors_wbg.size());

    for (auto *ptr : _monitors_wbg) {
        if (ptr) {
            tmp.push_back(ptr);
        }
    }
    _monitors_wbg.swap(tmp);
}

@namespace_end@
