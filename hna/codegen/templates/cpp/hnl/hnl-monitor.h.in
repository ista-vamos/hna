// #pragma once is buggy if we generate multiple HNL monitors
// and try to include them in the HNA monitor. We have to use
// normal include guards. However, they must be different for each HNL
// monitor

#ifndef HNL_MONITOR_H__@MONITOR_NAME@
#define HNL_MONITOR_H__@MONITOR_NAME@

#include <vector>
#include <list>
#include <memory>

#ifdef MEASURE_CPUTIME
// There's no guarantee that chrono::high_resolution_clock will actually measure
// CPU time, so use clock_gettime from `ctime`
#include <ctime>
#endif // !MEASURE_CPUTIME

#include "verdict.h"
#include "monitor.h"
#include "atom-monitor.h"
#include "function.h"
#include "trace.h"
#include "traceset.h"
#include "sharedtraceset.h"
#include "tracesetview.h"
#include "cmd.h"

#include "hnl-monitor-base.h"

/* generated */
#include "hnl-instance.h"
#include "functions.h"
#include "atom-identifier.h"

@namespace_start@


class HNLMonitor : public HNLMonitorBase {
protected:
  std::vector<std::unique_ptr<@namespace@::HNLInstance>> _instances;
  // XXX: based on profiling, we could keep a vector of raw pointers
  //  (additionally to this vector) that we would you for iterating over the atoms.
  // (Or we do it entirely event driven -- update the atoms for which the traces were updated)
  std::vector<std::unique_ptr<@namespace@::AtomMonitor>> _atom_monitors;

  #include "function-instances.h"

  // check for new traces and create HNLInstances for them
  // if there are some
  virtual bool addNewTraces();

  void condenseAtomsVector();

  CmdArgs *_cmd;

public:
  HNLMonitor(CmdArgs *cmd = nullptr) : _cmd(cmd) {
    #include "functions-initialize.h"
  }

  virtual ~HNLMonitor() {}

  Verdict step();

  AtomMonitor *createAtomMonitor(HNLEvaluationState monitor_type, @namespace@::HNLInstance&);
  void removeInstance(HNLInstance *instance);

  // statistics
  struct {
    // number of HNL configurations
    size_t num_instances{0};
    // number of atom monitors
    size_t num_atoms{0};

    // CPU time taken by running the HNL monitor
    #ifdef MEASURE_CPUTIME
    struct timespec cputime{0, 0};
    struct timespec cputime_adding_instances{0, 0};
    #endif
  } stats;
};


// specialization of the monitor for function atoms -- this one does not own the trace set,
// but only uses a view of existing trace sets
class FunctionHNLMonitor : public HNLMonitor {
  TraceSetView _traces_l;
  TraceSetView _traces_r;

  bool addNewTraces() override;

public:
    FunctionHNLMonitor(CmdArgs *cmd = nullptr) : HNLMonitor(cmd) {}
    
    FunctionHNLMonitor(SharedTraceSet& traces_l, Trace *tr) : _traces_l(traces_l), _traces_r(tr) {}
    // the `bool` here is just a dummy argument so that we can overload
    FunctionHNLMonitor(Trace *tl, SharedTraceSet& traces_r) : _traces_l(tl), _traces_r(traces_r) {}
    FunctionHNLMonitor(SharedTraceSet& traces_l, SharedTraceSet& traces_r) : _traces_l(traces_l),  _traces_r(traces_r) {}
};

#endif // !HNL_MONITOR_H__@MONITOR_NAME@

@namespace_end@
